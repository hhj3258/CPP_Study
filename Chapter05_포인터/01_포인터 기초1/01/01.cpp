#include <iostream>
using namespace std;

// [ 매개변수(hp의 주소) ][ RET ][ 지역변수 ]
// void SetHp(int* hp) --> void SetHP(hp의 주소)
void SetHp(int* hp) 
{
    // *hp = 100; --> hp의 주소로 이동해라.(순간이동)
    *hp = 100;
}

int main()
{
    int hp = 1;
    cout << hp << endl;
    SetHp(&hp);
    cout << hp << endl;

    int number = 1;
    // TYPE* 변수이름;
    // 일단 2가지 요소
    // - TYPE
    // - *

    // 바구니는 바구니인데...
    // [주소를 저장하는 바구니다!]
    // 변수 선언할 때 * 등장했다 -> 포인터 = 주소
    // 참고) 포인터라는 바구니는 4바이트(32비트) or 8바이트(64바이트) 고정 크기
    // ptr의 주소 = &ptr = 0x007CFA64
    // ptr이 가리키는 것 = 007cfa70 = number의 주소 = &number
    int* ptr = &number;
    
    // 근데 남의 주소를 갖고 뭘 하라는거지?
    // 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!!
    // *변수이름 = 값;
    
    // 포탈을 타고 순간이동 한다고 생각해보자.
    // * 이 여러번 등장하니 헷갈리는데, 사용 시점에 따라서 구분해서 기억하자.
    //    - 변수 선언(주소를 저장하는 바구니다!)
    //    - 사용할 때(포탈 타고 순간이동)

    int value1 = *ptr;
    //*ptr = 2;
    
    // TYPE은 왜 붙여줄까?
    // * = 포인터의 의미 = 주소를 저장하는 바구니 = 4 or 8 바이트 고정 크기
    // 주소에 가면 뭐가 있는데?
    // ex01) 결혼식 청첩장에 있는 주소 = 예식장 주소
    // ex02) 명함에 있는 주소 = 회사 주소
    // * = 포인터 (주소 담는 바구니)
    // TYPE을 명시해주지 않으면 해당 포인터가 무엇을 가리키고 있는지 명확히 알기(분석하기)가 어렵다
    // 몇 바이트 크기의 자료형인지에 따라서 해석을 다르게 할 수 있기 때문

    // 주의) 타입의 불일치
    // number 는 int 형(4바이트 정수)인데, __int64 형(8바이트 정수)로 캐스팅 한다면?
    // 다른 메모리 주소를 침범하여 값을 덮어쓰게 된다. -> 데이터가 오염된다.
    __int64* ptr2 = (__int64*)&number;
    *ptr2 = 0xAABBCCDDEEFF;     //  AABB CCDDEEFF -> AABB가 다른 메모리 주소에 쓰여진다.
    
    return 0;
}